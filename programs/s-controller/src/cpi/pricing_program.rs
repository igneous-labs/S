use pricing_programs_interface::{
    PriceExactInIxArgs, PriceExactInIxData, PriceExactOutIxArgs, PriceExactOutIxData,
    PriceLpTokensToMintIxArgs, PriceLpTokensToMintIxData, PriceLpTokensToRedeemIxArgs,
    PriceLpTokensToRedeemIxData,
};
use s_controller_interface::SControllerError;
use s_controller_lib::try_pool_state;
use sanctum_misc_utils::{get_borsh_return_data, ToAccountMeta};
use solana_program::{
    account_info::AccountInfo,
    instruction::{AccountMeta, Instruction},
    program::invoke,
    program_error::ProgramError,
};

use crate::account_traits::SrcDstLstMintAccountInfos;

#[derive(Clone, Copy, Debug)]
pub struct PricingProgramIxArgs {
    /// Amount of LST
    pub amount: u64,
    /// SOL value of `amount` LST
    pub sol_value: u64,
}

/// CPI call to either `PriceLpTokensToRedeem` or `PriceLpTokensToMint`
#[derive(Clone, Copy, Debug)]
pub struct PricingProgramPriceLpCpi<'me, 'info> {
    /// The pricing program to invoke
    pub program: &'me AccountInfo<'info>,

    /// The mint of the LST that the pricing program is being called for
    pub lst_mint: &'me AccountInfo<'info>,

    /// Remaining accounts required by the pricing program
    pub remaining_accounts: &'me [AccountInfo<'info>],
}

impl<'me, 'info> PricingProgramPriceLpCpi<'me, 'info> {
    /// Args:
    /// - `ix_accounts`: the calling instruction's accounts, excluding accounts_suffix_slice.
    ///     Should be a `*Accounts` struct generated by solores
    /// - `accounts_suffix_slice`: subslice of instruction accounts where first account is the pricing program
    ///     and remaining slice is remaining_accounts (excludes `lst_mint`)
    pub fn from_lst_mint_and_account_suffix_slice(
        lst_mint: &'me AccountInfo<'info>,
        accounts_suffix_slice: &'me [AccountInfo<'info>],
    ) -> Result<Self, ProgramError> {
        let program = accounts_suffix_slice
            .first()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;
        Ok(Self {
            program,
            lst_mint,
            remaining_accounts: accounts_suffix_slice
                .get(1..)
                .ok_or(ProgramError::NotEnoughAccountKeys)?,
        })
    }

    pub fn verify_correct_pricing_program(
        &self,
        pool_state: &'me AccountInfo<'info>,
    ) -> Result<(), ProgramError> {
        let pool_state_bytes = pool_state.try_borrow_data()?;
        let pool_state = try_pool_state(&pool_state_bytes)?;
        if *self.program.key != pool_state.pricing_program {
            return Err(SControllerError::IncorrectPricingProgram.into());
        }
        Ok(())
    }

    pub fn invoke_price_lp_tokens_to_mint(
        self,
        args: PricingProgramIxArgs,
    ) -> Result<u64, ProgramError> {
        let ix = self.create_price_lp_tokens_to_mint_ix(args)?;
        self.invoke_interface_ix(ix)
    }

    pub fn invoke_price_lp_tokens_to_redeem(
        self,
        args: PricingProgramIxArgs,
    ) -> Result<u64, ProgramError> {
        let ix = self.create_price_lp_tokens_to_redeem_ix(args)?;
        self.invoke_interface_ix(ix)
    }

    fn create_price_lp_tokens_to_mint_ix(
        &self,
        PricingProgramIxArgs { amount, sol_value }: PricingProgramIxArgs,
    ) -> Result<Instruction, ProgramError> {
        Ok(Instruction {
            program_id: *self.program.key,
            accounts: self.create_account_metas(),
            data: PriceLpTokensToMintIxData(PriceLpTokensToMintIxArgs { amount, sol_value })
                .try_to_vec()?,
        })
    }

    fn create_price_lp_tokens_to_redeem_ix(
        &self,
        PricingProgramIxArgs { amount, sol_value }: PricingProgramIxArgs,
    ) -> Result<Instruction, ProgramError> {
        Ok(Instruction {
            program_id: *self.program.key,
            accounts: self.create_account_metas(),
            data: PriceLpTokensToRedeemIxData(PriceLpTokensToRedeemIxArgs { amount, sol_value })
                .try_to_vec()?,
        })
    }

    fn invoke_interface_ix(self, interface_ix: Instruction) -> Result<u64, ProgramError> {
        let accounts = self.create_account_info_slice();
        invoke(&interface_ix, &accounts)?;
        let (_pk, res) = get_borsh_return_data().ok_or(SControllerError::FaultyPricingProgram)?;
        Ok(res)
    }

    fn create_account_info_slice(self) -> Vec<AccountInfo<'info>> {
        let Self {
            lst_mint,
            remaining_accounts,
            ..
        } = self;
        [std::slice::from_ref(lst_mint), remaining_accounts].concat()
    }

    fn create_account_metas(&self) -> Vec<AccountMeta> {
        let mut res = vec![AccountMeta::new_readonly(*self.lst_mint.key, false)];
        for r in self.remaining_accounts.iter() {
            res.push(r.to_account_meta());
        }
        res
    }
}

/// CPI call to either `PriceLpTokensToRedeem` or `PriceLpTokensToMint`
#[derive(Clone, Copy, Debug)]
pub struct PricingProgramPriceSwapCpi<'me, 'info> {
    /// The pricing program to invoke
    pub program: &'me AccountInfo<'info>,

    pub input_lst_mint: &'me AccountInfo<'info>,

    pub output_lst_mint: &'me AccountInfo<'info>,

    /// Remaining accounts required by the pricing program
    pub remaining_accounts: &'me [AccountInfo<'info>],
}

impl<'me, 'info> PricingProgramPriceSwapCpi<'me, 'info> {
    /// Args:
    /// - `ix_accounts`: the calling instruction's accounts, excluding accounts_suffix_slice.
    ///     Should be a `*Accounts` struct generated by solores
    /// - `accounts_suffix_slice`: subslice of instruction accounts where first account is the pricing program
    ///     and remaining slice is remaining_accounts (excludes `input_lst_mint` and `output_lst_mint`)
    pub fn from_src_dst_lst_mints_and_account_suffix_slice(
        SrcDstLstMintAccountInfos {
            src_lst_mint,
            dst_lst_mint,
        }: SrcDstLstMintAccountInfos<'me, 'info>,
        accounts_suffix_slice: &'me [AccountInfo<'info>],
    ) -> Result<Self, ProgramError> {
        let program = accounts_suffix_slice
            .first()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;
        Ok(Self {
            program,
            input_lst_mint: src_lst_mint,
            output_lst_mint: dst_lst_mint,
            remaining_accounts: accounts_suffix_slice
                .get(1..)
                .ok_or(ProgramError::NotEnoughAccountKeys)?,
        })
    }

    pub fn verify_correct_pricing_program(
        &self,
        pool_state: &'me AccountInfo<'info>,
    ) -> Result<(), ProgramError> {
        let pool_state_bytes = pool_state.try_borrow_data()?;
        let pool_state = try_pool_state(&pool_state_bytes)?;
        if *self.program.key != pool_state.pricing_program {
            return Err(SControllerError::IncorrectPricingProgram.into());
        }
        Ok(())
    }

    pub fn invoke_price_exact_out(self, args: PricingProgramIxArgs) -> Result<u64, ProgramError> {
        let ix = self.create_price_exact_out_ix(args)?;
        self.invoke_interface_ix(ix)
    }

    pub fn invoke_price_exact_in(self, args: PricingProgramIxArgs) -> Result<u64, ProgramError> {
        let ix = self.create_price_exact_in_ix(args)?;
        self.invoke_interface_ix(ix)
    }

    fn create_price_exact_out_ix(
        &self,
        PricingProgramIxArgs { amount, sol_value }: PricingProgramIxArgs,
    ) -> Result<Instruction, ProgramError> {
        Ok(Instruction {
            program_id: *self.program.key,
            accounts: self.create_account_metas(),
            data: PriceExactOutIxData(PriceExactOutIxArgs { amount, sol_value }).try_to_vec()?,
        })
    }

    fn create_price_exact_in_ix(
        &self,
        PricingProgramIxArgs { amount, sol_value }: PricingProgramIxArgs,
    ) -> Result<Instruction, ProgramError> {
        Ok(Instruction {
            program_id: *self.program.key,
            accounts: self.create_account_metas(),
            data: PriceExactInIxData(PriceExactInIxArgs { amount, sol_value }).try_to_vec()?,
        })
    }

    fn invoke_interface_ix(self, interface_ix: Instruction) -> Result<u64, ProgramError> {
        let accounts = self.create_account_info_slice();
        invoke(&interface_ix, &accounts)?;
        let (_pk, res) = get_borsh_return_data().ok_or(SControllerError::FaultyPricingProgram)?;
        Ok(res)
    }

    fn create_account_info_slice(self) -> Vec<AccountInfo<'info>> {
        let Self {
            input_lst_mint,
            output_lst_mint,
            remaining_accounts,
            ..
        } = self;
        [
            std::slice::from_ref(input_lst_mint),
            std::slice::from_ref(output_lst_mint),
            remaining_accounts,
        ]
        .concat()
    }

    fn create_account_metas(&self) -> Vec<AccountMeta> {
        let mut res = vec![
            AccountMeta::new_readonly(*self.input_lst_mint.key, false),
            AccountMeta::new_readonly(*self.output_lst_mint.key, false),
        ];
        for r in self.remaining_accounts.iter() {
            res.push(r.to_account_meta());
        }
        res
    }
}
